<?xml version="1.0" encoding="UTF-8" ?>
<ChoregrapheProject xmlns="http://www.ald.softbankrobotics.com/schema/choregraphe/project.xsd" xar_version="3">
  <Box name="root" id="-1" localization="8" tooltip="Root box of Choregraphe&apos;s behavior. Highest level possible." x="0" y="0">
    <bitmap>media/images/box/root.png</bitmap>
    <script language="4">
      <content>
        <![CDATA[]]>
      </content>
    </script>
    <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
    <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
    <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
    <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
    <Timeline enable="0">
      <BehaviorLayer name="behavior_layer1">
        <BehaviorKeyframe name="keyframe1" index="1">
          <Diagram>
            <Box name="Python Script" id="1" localization="8" tooltip="This box contains a basic python script and can be used to create any python script box you would like.&#x0A;&#x0A;To edit its script, double-click on it." x="397" y="243">
              <bitmap>media/images/box/box-python-script.png</bitmap>
              <script language="4">
                <content>
                  <![CDATA[# -*- coding: utf-8 -*-
import socket
import json
import time
import urllib2
from naoqi import ALProxy

NAO_IP = "172.20.10.4"         # <–– sostituire con IP di NAO>
NAO_PORT = 9559

MKR_IP = "172.20.10.7"          # <–– IP di Arduino MKR>
MKR_PORT = 5005

FLASK_SERVER_URL = "http://172.20.10.3:5000"   # <–– IP del PC>


# =============================================================
# 2) Proxy Text-to-Speech
# =============================================================
tts = ALProxy("ALTextToSpeech", NAO_IP, NAO_PORT)

def parla(msg):
    print("[CHOREGRAPHE]", msg)
    try:
        tts.say(msg)
    except:
        pass

def descrivi_mossa(mossa):
    """
    mossa è sempre stringa formattata (es. "e2xe4" o "e7e5").
    Restituisce frase adatta a TTS.
    """
    if "x" in mossa:
        partenza, arrivo = mossa.split("x")
        return "cattura da {} a {}".format(partenza, arrivo)
    elif len(mossa) == 4:
        return "da {} a {}".format(mossa[:2], mossa[2:])
    return mossa

def invia_comando_mkr(etichetta, mossa):
    """
    etichetta: "utente" o "nao"
    mossa: stringa formattata (es. "e2xe4" o "e7e5")
    Invia via TCP a MKR e ritorna la risposta.
    """
    try:
        comando = "{}:{}".format(etichetta, mossa)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((MKR_IP, MKR_PORT))
        s.sendall((comando + "\n").encode('utf-8'))
        risposta = s.recv(1024).decode('utf-8')
        s.close()
        print("[CHOREGRAPHE] Comando inviato:", comando)
        return risposta
    except Exception as e:
        parla("Errore nel collegamento con il microcontrollore")
        return "errore"

def get_user_move():
    """
    Restituisce l’ultima mossa formattata dell’utente (es. "e2xe4") presa da Flask.
    """
    try:
        response = urllib2.urlopen(FLASK_SERVER_URL + "/get_user_move")
        result = json.loads(response.read())
        return result["move"]
    except:
        return None

def get_stockfish_move(moves_list):
    """
    moves_list: lista di UCI puro (es. ["e2e4","e7e5",...]).
    Va su /getmove, ottiene JSON {"move":"<UCI>","formatted":"<formattata>"}.
    """
    try:
        data = json.dumps({"moves": moves_list})
        req = urllib2.Request(FLASK_SERVER_URL + "/getmove", data=data)
        req.add_header("Content-Type", "application/json")
        response = urllib2.urlopen(req)
        result = json.loads(response.read())
        return result
    except:
        return None

def post_user_move_to_server(move):
    """
    Move è stringa formattata (es. "e2xe4").
    Manda a Flask su /post_user_move.
    """
    try:
        data = json.dumps({"move": move})
        req = urllib2.Request(FLASK_SERVER_URL + "/post_user_move", data=data)
        req.add_header("Content-Type", "application/json")
        urllib2.urlopen(req)
    except:
        pass

def is_game_over(moves_list):
    """
    moves_list: lista di UCI puro (es. ["e2e4","e7e5",...]).
    Chiama Flask su /is_game_over e ritorna (game_over, result).
    result = "scaccomatto" o "patta" o "".
    """
    try:
        data = json.dumps({"moves": moves_list})
        req = urllib2.Request(FLASK_SERVER_URL + "/is_game_over", data=data)
        req.add_header("Content-Type", "application/json")
        response = urllib2.urlopen(req)
        result = json.loads(response.read())
        return result.get("game_over", False), result.get("result", "")
    except:
        return False, ""

def main():
    parla("Ciao, sono pronto a giocare.")
    moves = []   # Lista di UCI puro (senza "x"), es. ["e2e4","e7e5",...]

    while True:
        # ===========================================================
        # 1) Aspettiamo la mossa dell’utente
        # ===========================================================
        parla("Aspetto la tua mossa.")
        user_move = None

        # Facciamo polling per un minuto (600 * 0.1s)
        for _ in range(600):
            new_move = get_user_move()   # es. "e2xe4"
            if new_move and new_move not in moves:
                user_move = new_move
                break
            time.sleep(0.1)

        if not user_move:
            parla("Non ho ricevuto una nuova mossa. Termino qui.")
            break

        # user_move è formattata (es. "e2xe4" o "g1f3")
        # Per la lista interna di UCI (moves), tolgo "x"
        uci_user = user_move.replace("x", "")  # es. "e2e4"
        parla("Hai mosso {}".format(descrivi_mossa(user_move)))
        moves.append(uci_user)

        # Comunichiamo a Flask e a MKR
        post_user_move_to_server(user_move)       # mossa formattata
        invia_comando_mkr("utente", user_move)    # mossa formattata

        # ===========================================================
        # 2) Subito dopo la mossa utente, controlliamo se è stato dato scaccomatto/patta
        # ===========================================================
        game_over, result = is_game_over(moves)
        if game_over:
            # Se il giocatore ha dato scaccomatto a Stockfish (perché ha mosso lui)
            if result == "scaccomatto":
                parla("Complimenti, hai vinto per scaccomatto!")
            else:  # copre "patta"
                parla("La partita è patta.")
            break

        # ===========================================================
        # 3) Tocca a Stockfish / NAO
        # ===========================================================
        parla("Ora tocca a me.")
        sf_response = get_stockfish_move(moves)
        if not sf_response:
            parla("Errore nel calcolo della mia mossa. Termino qui.")
            break

        uci_sf = sf_response["move"]              # es. "b8c6"
        formatted_sf = sf_response["formatted"]   # es. "b8xc6" se cattura

        # NAO pronuncia e invia ad MKR
        parla("Muovo {}".format(descrivi_mossa(formatted_sf)))
        moves.append(uci_sf)  # salvo UCI puro per la prossima valutazione

        invia_comando_mkr("nao", formatted_sf)  # mando la notazione con "x" se serve

        # ===========================================================
        # 4) Dopo la mossa di NAO, controllo nuovamente game over
        # ===========================================================
        game_over, result = is_game_over(moves)
        if game_over:
            # HA dato scaccomatto NAO (quindi ha vinto NAO)
            if result == "scaccomatto":
                parla("Ho dato scaccomatto, ho vinto!")
            else:
                parla("Patta!")
            break

    parla("Grazie per la partita!")

main()]]>
                </content>
              </script>
              <Input name="onLoad" type="1" type_size="1" nature="0" inner="1" tooltip="Signal sent when diagram is loaded." id="1" />
              <Input name="onStart" type="1" type_size="1" nature="2" inner="0" tooltip="Box behavior starts when a signal is received on this input." id="2" />
              <Input name="onStop" type="1" type_size="1" nature="3" inner="0" tooltip="Box behavior stops when a signal is received on this input." id="3" />
              <Output name="onStopped" type="1" type_size="1" nature="1" inner="0" tooltip="Signal sent when box behavior is finished." id="4" />
            </Box>
            <Link inputowner="1" indexofinput="2" outputowner="0" indexofoutput="2" />
            <Link inputowner="0" indexofinput="4" outputowner="1" indexofoutput="4" />
          </Diagram>
        </BehaviorKeyframe>
      </BehaviorLayer>
    </Timeline>
  </Box>
</ChoregrapheProject>
